// utf8.h

#pragma once

#include <inttypes.h>
#include <string.h>

// Unicode Code Point
typedef uint32_t ucp;
typedef uint8_t byte;

//
// UTF-8 Decoder
//
// This struct and associated functions can be used for on-line decoding of byte streams.
// It is the basis for the other array-based decoding functions that follow.
typedef struct {
	int state, seqLength;
	ucp c;
} UTF8_Decoder;
// Prepares a decoder for use.
void UTF8_Decoder_init(UTF8_Decoder*);
// Decodes the given byte.
// If an invalid byte is given, *error will be set to the appropriate error code.
// If an overlong sequence is encountered, *error will be set to UTF8_ERROR_OVERLONG_SEQUENCE for the last byte of the sequence and no character will be generated.
// Otherwise, *error will be set to 0.
// If a character is generated by decoding the given byte, *c will be set to that character and the return value will point to the character after *c.
#define UTF8_ERROR_INVALID_START_BYTE 1 // Invalid start byte
#define UTF8_ERROR_INVALID_CONTINUATION_BYTE 2 // Invalid continuation byte
#define UTF8_ERROR_OVERLONG_SEQUENCE 3 // Input contains an overlong sequence
ucp* UTF8_Decoder_decode(UTF8_Decoder*, byte b, ucp* c, int* error);
// Returns non-zero if the decoder is in a state where the input can be terminated (i.e., returns whether the decoder is NOT in the middle of a multi-byte sequence).
int UTF8_Decoder_canTerminate(UTF8_Decoder*);

//
// UTF-8 Decoding Functions
//
// Decodes bc bytes in the ba byte array generating up to cc characters in the ca character array.
// If an error occurs, *error will be set to the appropriate error code.
// This may be one of the error codes for the UTF8_Decoder_decode function, or one of the additional error codes given below.
// If no error occurs, *error will be set to 0.
// Returns a pointer to the next (unused) character.
#define UTF8_ERROR_CHAR_OVERFLOW 4 // More than cc characters would be generated
#define UTF8_ERROR_UNEXPECTED_TERMINATION 5 // Input byte sequence was not terminated on a character boundary
ucp* UTF8_DecodeArray(byte* ba, size_t bc, ucp* ca, size_t cc, int* error);
// Similar to the above, except that the input byte array is a char array terminated by null.
ucp* UTF8_DecodeString(const char* str, ucp* ca, size_t cc, int* error);

//
// UTF-8 Encoding Functions
//
// Returns the number of bytes necessary to encode the given character.
// This will be a number between 1 and 4 inclusively.
int UTF8_BytesForChar(ucp);
// Encodes the given character into the given bytes, returning a pointer to the next (unused) byte.
byte* UTF8_EncodeChar(ucp, byte*);
// Encodes cc characters from the ca character array into up to bc bytes of the ba byte array.
// If an error occurs, *error will be set to the appropriate error code.
// If no error occurs, *error will be set to 0.
// Returns a pointer to the next (unused) byte.
#define UTF8_ERROR_BYTE_OVERFLOW 6 // More than bc bytes would be generated
byte* UTF8_EncodeArray(ucp* ca, size_t cc, byte* ba, size_t bc, int* error);
